/* __V3D_TEMPLATE__ - template-based file; delete this line to prevent this file from being updated */

'use strict';

window.addEventListener('load', e => {
    const params = v3d.AppUtils.getPageParams();
    createApp({
        containerId: 'v3d-container',
        fsButtonId: 'fullscreen-button',
        sceneURL: params.load || '__URL__AEROCLADAR.glb'.replace('__URL__', ''),
        logicURL: params.logic || '__LOGIC__visual_logic.js'.replace('__LOGIC__', ''),
    });
});

async function createApp({containerId, fsButtonId = null, sceneURL, logicURL = ''}) {
    if (!sceneURL) {
        console.log('No scene URL specified');
        return;
    }

    // some puzzles can benefit from cache
    v3d.Cache.enabled = true;

    let PL = null, PE = null;
    if (v3d.AppUtils.isXML(logicURL)) {
        const PUZZLES_DIR = '/puzzles/';
        const logicURLJS = logicURL.match(/(.*)\.xml$/)[1] + '.js';
        PL = await new v3d.PuzzlesLoader().loadEditorWithLogic(PUZZLES_DIR, logicURLJS);
        PE = v3d.PE;
    } else if (v3d.AppUtils.isJS(logicURL)) {
        PL = await new v3d.PuzzlesLoader().loadLogic(logicURL);
    }

    let initOptions = { useFullscreen: true };
    if (PL) {
        initOptions = PL.execInitPuzzles({ container: containerId }).initOptions;
    }
    sceneURL = initOptions.useCompAssets ? `${sceneURL}.xz` : sceneURL;

    const disposeFullscreen = prepareFullscreen(containerId, fsButtonId,
            initOptions.useFullscreen);
    const preloader = createPreloader(containerId, initOptions, PE);

    const app = createAppInstance(containerId, initOptions, preloader, PE);
    app.addEventListener('dispose', () => disposeFullscreen && disposeFullscreen());

    if (initOptions.preloaderStartCb) initOptions.preloaderStartCb();
    app.loadScene(sceneURL, () => {
        app.enableControls();
        app.run();

        if (PE) PE.updateAppInstance(app);
        if (PL) PL.init(app, initOptions);

        runCode(app, PL);
    }, null, () => {
        console.log(`Can't load the scene ${sceneURL}`);
    });

    return { app, PL };
}


function createPreloader(containerId, initOptions, PE) {
    const preloader = initOptions.useCustomPreloader
            ? createCustomPreloader(initOptions.preloaderProgressCb,
            initOptions.preloaderEndCb)
            : new v3d.SimplePreloader({ container: containerId });

    if (PE) puzzlesEditorPreparePreloader(preloader, PE);

    return preloader;
}

function createCustomPreloader(updateCb, finishCb) {
    function CustomPreloader() {
        v3d.Preloader.call(this);
    }

    CustomPreloader.prototype = Object.assign(Object.create(v3d.Preloader.prototype), {
        onUpdate: function(percentage) {
            v3d.Preloader.prototype.onUpdate.call(this, percentage);
            if (updateCb) updateCb(percentage);
        },
        onFinish: function() {
            v3d.Preloader.prototype.onFinish.call(this);
            if (finishCb) finishCb();
        }
    });

    return new CustomPreloader();
}

/**
 * Modify the app's preloader to track the loading process in the Puzzles Editor.
 */
function puzzlesEditorPreparePreloader(preloader, PE) {
    const _onUpdate = preloader.onUpdate.bind(preloader);
    preloader.onUpdate = function(percentage) {
        _onUpdate(percentage);
        PE.loadingUpdateCb(percentage);
    }

    const _onFinish = preloader.onFinish.bind(preloader);
    preloader.onFinish = function() {
        _onFinish();
        PE.loadingFinishCb();
    }
}


function createAppInstance(containerId, initOptions, preloader, PE) {
    const ctxSettings = {};
    if (initOptions.useBkgTransp) ctxSettings.alpha = true;
    if (initOptions.preserveDrawBuf) ctxSettings.preserveDrawingBuffer = true;

    const app = new v3d.App(containerId, ctxSettings, preloader);
    if (initOptions.useBkgTransp) {
        app.clearBkgOnLoad = true;
        if (app.renderer) {
            app.renderer.setClearColor(0x000000, 0);
        }
    }

    // namespace for communicating with code generated by Puzzles
    app.ExternalInterface = {};
    prepareExternalInterface(app);
    if (PE) PE.viewportUseAppInstance(app);

    return app;
}


function prepareFullscreen(containerId, fsButtonId, useFullscreen) {
    const container = document.getElementById(containerId);
    const fsButton = document.getElementById(fsButtonId);

    if (!fsButton) {
        return null;
    }
    if (!useFullscreen) {
        if (fsButton) fsButton.style.display = 'none';
        return null;
    }

    const fsEnabled = () => document.fullscreenEnabled
            || document.webkitFullscreenEnabled
            || document.mozFullScreenEnabled
            || document.msFullscreenEnabled;
    const fsElement = () => document.fullscreenElement
            || document.webkitFullscreenElement
            || document.mozFullScreenElement
            || document.msFullscreenElement;
    const requestFs = elem => (elem.requestFullscreen
            || elem.mozRequestFullScreen
            || elem.webkitRequestFullscreen
            || elem.msRequestFullscreen).call(elem);
    const exitFs = () => (document.exitFullscreen
            || document.mozCancelFullScreen
            || document.webkitExitFullscreen
            || document.msExitFullscreen).call(document);
    const changeFs = () => {
        const elem = fsElement();
        fsButton.classList.add(elem ? 'fullscreen-close' : 'fullscreen-open');
        fsButton.classList.remove(elem ? 'fullscreen-open' : 'fullscreen-close');
    };

    function fsButtonClick(event) {
        event.stopPropagation();
        if (fsElement()) {
            exitFs();
        } else {
            requestFs(container);
        }
    }

    if (fsEnabled()) fsButton.style.display = 'inline';

    fsButton.addEventListener('click', fsButtonClick);
    document.addEventListener('webkitfullscreenchange', changeFs);
    document.addEventListener('mozfullscreenchange', changeFs);
    document.addEventListener('msfullscreenchange', changeFs);
    document.addEventListener('fullscreenchange', changeFs);

    const disposeFullscreen = () => {
        fsButton.removeEventListener('click', fsButtonClick);
        document.removeEventListener('webkitfullscreenchange', changeFs);
        document.removeEventListener('mozfullscreenchange', changeFs);
        document.removeEventListener('msfullscreenchange', changeFs);
        document.removeEventListener('fullscreenchange', changeFs);
    }

    return disposeFullscreen;
}


function prepareExternalInterface(app) {
    /**
     * Register functions in the app.ExternalInterface to call them from
     * Puzzles, e.g:
     * app.ExternalInterface.myJSFunction = function() {
     *     console.log('Hello, World!');
     * }
     */

}

function runCode(app, puzzles) {
    // Set background image for the scene
    app.scene.background = new v3d.TextureLoader().load("images/BGGradient.jpg");

    let isARActive = false;
    let isPointerDown = false;
    
    let startPoint = { x: 0, y: 0 };
    let deltaX = 0, deltaY = 0;

    const yawAxis = new v3d.Vector3(0, 1, 0); // World Y-axis (global up)
    const cameraRight = new v3d.Vector3();
        
    let v3dContainer = document.getElementById('v3d-container');
    let model = app.scene.getObjectByName('Aero Clad');

    // Handle AR session
    app.renderer.xr.addEventListener('sessionstart', function(event){
        isARActive = true;
    });

    // Perform Zoom In
    document
    .getElementById("zoomIn")
    .addEventListener("click", function() {
        if (!isARActive){
            zoomViewIn(app);
        }else{
            zoomObjectIn(app);
        }
    });

    // Perform Zoom Out 
    document
    .getElementById("zoomOut")
    .addEventListener("click", function() {
        if (!isARActive){
            zoomViewOut(app);
        }else{
            zoomObjectOut(app);
        }
    });

    // Event listeners for touch and drag
    v3dContainer.addEventListener('touchstart', function(event) {      
        isPointerDown = true;
        startPoint.x = event.touches[0].clientX;
        startPoint.y = event.touches[0].clientY;
                   
    }, false);

    v3dContainer.addEventListener('touchmove', function(event) {
        if (!isPointerDown || !model) return;
    
        if (isARActive){
            deltaX = event.touches[0].clientX - startPoint.x;
            deltaY = event.touches[0].clientY - startPoint.y;

            const rotationSpeed = 0.005; 

            // Determine if the movement is more horizontal or vertical
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal drag (rotate around the Y-axis)
                const yaw = deltaX * rotationSpeed;
                const yawQuaternion = new v3d.Quaternion().setFromAxisAngle(yawAxis, yaw);
                
                // Apply yaw rotation
                model.quaternion.premultiply(yawQuaternion);
            } else {
                // Vertical drag (rotate around the camera's right axis)
                app.camera.getWorldDirection(cameraRight);
                cameraRight.cross(new v3d.Vector3(0, 1, 0)); // Get right direction from camera
                const pitch = deltaY * rotationSpeed;
                const pitchQuaternion = new v3d.Quaternion().setFromAxisAngle(cameraRight, pitch);
                
                // Apply pitch rotation
                model.quaternion.premultiply(pitchQuaternion);
            }

            // Normalize quaternion to avoid precision errors
            model.quaternion.normalize();

            // Update startPoint for continuous drag
            startPoint.x = event.touches[0].clientX;
            startPoint.y = event.touches[0].clientY;
        }
        
    }, false);

    v3dContainer.addEventListener('touchend', function() {
        isPointerDown = false;

    }, false);

    // Create annotations
    createAnnotations(app);

}

/**
* Zoom In: Updates the camera's position based on the zoom level using LERP
* @param {*} app
*/
function zoomViewIn(app) {
    let animationStartTime = performance.now();
        
    requestAnimationFrame(function(currentTime) {
        animateZoom(currentTime, animationStartTime, false, app);
    });
}

/**
 * Zoom Out: Updates the camera's position based on the zoom level using LERP
 * @param {*} app
 */
function zoomViewOut(app) {
    let animationStartTime = performance.now();
        
    requestAnimationFrame(function(currentTime) {
        animateZoom(currentTime, animationStartTime, true, app);
    });
}

/**
 * Animate Zoom: Animate camera's position with smooth transition using LERP
 * @param {*} currentTime
 * @param {*} animationStartTime
 * @param {*} viewOut
 * @param {*} app
 */
function animateZoom(currentTime, animationStartTime, viewOut, app) {
    let fixedZoom = 0.2;
    let animationDuration = 250; // duration in milliseconds
    
    //if (!animationStartTime) animationStartTime = currentTime;

    let elapsed = currentTime - animationStartTime;
    
    if (elapsed < animationDuration) {
        let progress = elapsed / animationDuration;
        let currentZoom = v3d.MathUtils.lerp(0.0, fixedZoom, progress);
            
        updateZoom(app, currentZoom, viewOut);
            
        requestAnimationFrame(function(timestamp) {
            animateZoom(timestamp, animationStartTime, viewOut, app);
        });

    } else {
        updateZoom(app, fixedZoom, viewOut);
        animationStartTime = 0; // Reset animation timer
    }
}

/**
 * Update Zoom: Compute camera position based on look at direction & zoom level
 * @param {*} zoomLevel
 * @param {*} viewOut
 * @param {*} app
 */
function updateZoom(app, zoomLevel, viewOut) {  
    let sceneCamera = app.camera;
    
    // Calculate the new camera position based on look direction and zoom
    let lookAtDirection = new v3d.Vector3();
    sceneCamera.getWorldDirection(lookAtDirection);
    
    // Update the camera's position
    if(viewOut){
        let newCameraPosition = sceneCamera.position.clone().sub(lookAtDirection.multiplyScalar(zoomLevel));
        sceneCamera.position.copy(newCameraPosition);
    }
    else{
        let newCameraPosition = sceneCamera.position.clone().add(lookAtDirection.multiplyScalar(zoomLevel));
        sceneCamera.position.copy(newCameraPosition);
    } 
}

/**
* Zoom Object In (AR Mode): Updates the object's position based on the zoom level using LERP
* @param {*} app
*/
function zoomObjectIn(app) {
    let animStartTime = performance.now();
        
    requestAnimationFrame(function(currentTime) {
        objectZoom(currentTime, animStartTime, false, app);
    });
}

/**
 * Zoom Object Out (AR Mode): Updates the object's position based on the zoom level using LERP
 * @param {*} app
 */
function zoomObjectOut(app) {
    let animStartTime = performance.now();
            
    requestAnimationFrame(function(currentTime) {
        objectZoom(currentTime, animStartTime, true, app);
    });
}

/**
 * Animate Object Zoom: Animate object's position with smooth transition using LERP
 * @param {*} currentTime
 * @param {*} animationStartTime
 * @param {*} viewOut
 * @param {*} app
 */
function objectZoom(currentTime, animationStartTime, viewOut, app) {
    let fixedZoom = 0.05;
    let animationDuration = 250; // duration in milliseconds
    
    //if (!animationStartTime) animationStartTime = currentTime;

    let elapsed = currentTime - animationStartTime;
    
    if (elapsed < animationDuration) {
        let progress = elapsed / animationDuration;
        let currentZoom = v3d.MathUtils.lerp(0.0, fixedZoom, progress);
            
        updateObjectZoom(app, currentZoom, viewOut);
            
        requestAnimationFrame(function(timestamp) {
        objectZoom(timestamp, animationStartTime, viewOut, app);
    });

    } else {
        updateObjectZoom(app, fixedZoom, viewOut);
        animationStartTime = 0; // Reset animation timer
    }
}

/**
 * Update Object Zoom: Compute object position based on look at direction & zoom level
 * @param {*} zoomLevel
 * @param {*} viewOut
 * @param {*} app
 */
function updateObjectZoom(app, zoomLevel, viewOut) {  
    
    const sceneObj = app.scene.getObjectByName('Aero Clad');
            
    // Calculate the new object position based on look direction and zoom level
    let lookAtDir = new v3d.Vector3();   
    app.camera.getWorldDirection(lookAtDir);
    lookAtDir.multiplyScalar(-1);
            
    // Update the object's position
    if(viewOut){
        let newObjPosition = sceneObj.position.clone().sub(lookAtDir.multiplyScalar(zoomLevel));
        sceneObj.position.copy(newObjPosition);
    }
    else{
        let newObjPosition = sceneObj.position.clone().add(lookAtDir.multiplyScalar(zoomLevel));
        sceneObj.position.copy(newObjPosition);
    }
}

/**
 * Create Annotations
 * @param {*} app
 */
function createAnnotations(app){
    let annotate01 = ('<b>Stainless steel / Aluminum composite material</b><br><br> ' + '\n' +
    'For more details about the product, check' + '\n' +
    '<a href="https://www.hendrickson-intl.com/products/aero-clad/aero-clad" style="color: yellow" target = "_blank">Hendrickson AERO CLAD</a>' + '\n' +
    '');  
                                
    // Add annotations to the scene
    handleAnnot(app, true, '1', 'steel_annotation', annotate01, 'an_1', undefined);
                                
    // Hide annotations (by default)
    setHTMLElemStyle('display', 'none', ['an_1'], false);
}

/**
   * Add annotations to the scene
  * @param {*} app
  * @param {*} add
  * @param {*} annot : Annotation ID to be displayed on the part
  * @param {*} objSelector : Part name
  * @param {*} contents : HTML content to be displayed
  * @param {*} id
   */
function handleAnnot(app, add, annot, objSelector, contents, id, name) {
    let obj = app.scene.getObjectByName(objSelector);
    if (add) {
      let aObj = new v3d.Annotation(app.container, annot, contents);
      aObj.name = findUniqueObjectName(name ? name : annot);
      aObj.fadeObscured = true; // Fade annotations (true) _pGlob.fadeAnnotations;
      if (id) {
          aObj.annotation.id = id;
          aObj.annotationDialog.id = id+'_dialog';
      }
      obj.add(aObj);
    }
  }
  
  /**
  * Utility function to find the first occurence of the object by its name
  * @param {*} app
  * @param {*} objName
  */
  function getObjectByName(app, objName) {
    let objFound;
    if (app.scene) {
        app.scene.traverse(function(obj) {
            if (!objFound && notIgnoredObj(obj) && (obj.name == objName)) {
                objFound = obj;            
            }
        });
    }
    return objFound;
  }
  
  /**
  * Utility function to find unique object name
  * @param {*} name
  */
  function findUniqueObjectName(name) {
    function objNameUsed(name) {
        return Boolean(getObjectByName(name));
    }
    while (objNameUsed(name)) {
        let r = name.match(/^(.*?)(\d+)$/);
        if (!r) {
            name += "2";
        } else {
            name = r[1] + (parseInt(r[2], 10) + 1);
        }
    }
    return name;
  }
  
  /**
  * Utility function to show / hide the annotations
  * @param {*} prop
  * @param {*} value
  * @param {*} ids
  * @param {*} isParent
  */
  function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
  }
  
  /**
  * Utility function that returns an array of elements given an array of ids
  * @param {*} ids
  * @param {*} isParent
  */
  function getElements(ids, isParent) {
    var elems = [];
    if (Array.isArray(ids) && ids[0] != 'CONTAINER' && ids[0] != 'WINDOW' &&
        ids[0] != 'DOCUMENT' && ids[0] != 'BODY' && ids[0] != 'QUERYSELECTOR') {
        for (var i = 0; i < ids.length; i++)
            elems.push(getElement(ids[i], isParent));
    } else {
        elems.push(getElement(ids, isParent));
    }
    return elems;
  }
  
  /**
  * Utility function that returns an element given an id
  * @param {*} id
  * @param {*} isParent
  */
  function getElement(id, isParent) {
    var elem;
    if (Array.isArray(id) && id[0] == 'CONTAINER') {
        if (appInstance !== null) {
            elem = appInstance.container;
        } else if (typeof _initGlob !== 'undefined') {
            // if we are on the initialization stage, we still can have access
            // to the container element
            var id = _initGlob.container;
            if (isParent) {
                elem = parent.document.getElementById(id);
            } else {
                elem = document.getElementById(id);
            }
        }
    } else if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
            elem = parent;
        else
            elem = window;
    } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
            elem = parent.document;
        else
            elem = document;
    } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
            elem = parent.document.body;
        else
            elem = document.body;
    } else if (Array.isArray(id) && id[0] == 'QUERYSELECTOR') {
        if (isParent)
            elem = parent.document.querySelector(id);
        else
            elem = document.querySelector(id);
    } else {
        if (isParent)
            elem = parent.document.getElementById(id);
        else
            elem = document.getElementById(id);
    }
    return elem;
  }